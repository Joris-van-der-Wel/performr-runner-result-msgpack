'use strict';

const {DATA_URL_TYPE} = require('./types');

const TYPE_BUFFER = Buffer.alloc(1, DATA_URL_TYPE);
const VERSION_BUFFER = Buffer.alloc(1, 0x1);
const NULL_BYTE_BUFFER = Buffer.alloc(1, 0x0);

// not all data: URL variations are supported (missing mime type or missing base64)
// these missing variations are not generated by performr-runner anyway
const DATA_URL_REGEXP = /^data:(.+?);\s*base64\s*,/;

exports.check = obj => Boolean(
    obj &&
    typeof obj === 'object' &&
    obj.dataURL === true &&
    typeof obj.data === 'string' &&
    DATA_URL_REGEXP.test(obj.data) &&
    Object.keys(obj).length === 2
);

exports.encode = obj => {
    const {data: dataURL} = obj;
    const [beforeData, mimeType] = DATA_URL_REGEXP.exec(dataURL);
    const dataBase64 = dataURL.substr(beforeData.length);

    const mimeTypeBuffer = Buffer.from(mimeType, 'utf8');
    const dataBuffer = Buffer.from(dataBase64, 'base64');

    return Buffer.concat([
        TYPE_BUFFER,
        VERSION_BUFFER,
        mimeTypeBuffer,
        NULL_BYTE_BUFFER,
        dataBuffer,
    ]);
};

exports.decode = buf => {
    // buf is without the type here

    const version = buf.readUInt8(0);

    if (version !== 0x1) {
        throw Error(`dataURL.decode(): Unsupported version ${version.toString(16)} for data URL type (${DATA_URL_TYPE.toString(16)})`);
    }

    const mimeTypeEnd = buf.indexOf(0x0, 1);

    if (mimeTypeEnd < 0) {
        throw Error('dataURL.decode(): Unable to find end of mime-type string');
    }

    const mimeType = buf.toString('utf8', 1, mimeTypeEnd);
    const dataBase64 = buf.toString('base64', mimeTypeEnd + 1);

    return {
        data: 'data:' + mimeType + ';base64,' + dataBase64,
        dataURL: true,
    };
};


// data:image/jpeg;base64,
